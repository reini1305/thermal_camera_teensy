/***************************************************************************
  This is a library for the AMG88xx GridEYE 8x8 IR camera

  This sketch makes an inetrpolated pixel thermal camera with the 
  GridEYE sensor and a 2.4" tft featherwing:
	 https://www.adafruit.com/product/3315

  Designed specifically to work with the Adafruit AMG8833 Featherwing
          https://www.adafruit.com/product/3622

  These sensors use I2C to communicate. The device's I2C address is 0x69

  Adafruit invests time and resources providing this open source code,
  please support Adafruit andopen-source hardware by purchasing products
  from Adafruit!

  Written by Dean Miller, James DeVito & ladyada for Adafruit Industries.
  BSD license, all text above must be included in any redistribution
 ***************************************************************************/
#include <SD.h>
#include <SPI.h>
#include <TFT.h>

#include <Wire.h>
#include <Adafruit_AMG88xx.h>

#include <EEPROM.h>

// pin definitions
#define cs   10
#define dc   9
#define rst  8
#define cs_sd 7
#define input 6

TFT tft = TFT(cs, dc, rst);


//low range of the sensor (this will be blue on the screen)
#define MINTEMP 0

//high range of the sensor (this will be red on the screen)
#define MAXTEMP 800

//jet
uint16_t jet[] = {0x480F,
0x400F,0x400F,0x400F,0x4010,0x3810,0x3810,0x3810,0x3810,0x3010,0x3010,
0x3010,0x2810,0x2810,0x2810,0x2810,0x2010,0x2010,0x2010,0x1810,0x1810,
0x1811,0x1811,0x1011,0x1011,0x1011,0x0811,0x0811,0x0811,0x0011,0x0011,
0x0011,0x0011,0x0011,0x0031,0x0031,0x0051,0x0072,0x0072,0x0092,0x00B2,
0x00B2,0x00D2,0x00F2,0x00F2,0x0112,0x0132,0x0152,0x0152,0x0172,0x0192,
0x0192,0x01B2,0x01D2,0x01F3,0x01F3,0x0213,0x0233,0x0253,0x0253,0x0273,
0x0293,0x02B3,0x02D3,0x02D3,0x02F3,0x0313,0x0333,0x0333,0x0353,0x0373,
0x0394,0x03B4,0x03D4,0x03D4,0x03F4,0x0414,0x0434,0x0454,0x0474,0x0474,
0x0494,0x04B4,0x04D4,0x04F4,0x0514,0x0534,0x0534,0x0554,0x0554,0x0574,
0x0574,0x0573,0x0573,0x0573,0x0572,0x0572,0x0572,0x0571,0x0591,0x0591,
0x0590,0x0590,0x058F,0x058F,0x058F,0x058E,0x05AE,0x05AE,0x05AD,0x05AD,
0x05AD,0x05AC,0x05AC,0x05AB,0x05CB,0x05CB,0x05CA,0x05CA,0x05CA,0x05C9,
0x05C9,0x05C8,0x05E8,0x05E8,0x05E7,0x05E7,0x05E6,0x05E6,0x05E6,0x05E5,
0x05E5,0x0604,0x0604,0x0604,0x0603,0x0603,0x0602,0x0602,0x0601,0x0621,
0x0621,0x0620,0x0620,0x0620,0x0620,0x0E20,0x0E20,0x0E40,0x1640,0x1640,
0x1E40,0x1E40,0x2640,0x2640,0x2E40,0x2E60,0x3660,0x3660,0x3E60,0x3E60,
0x3E60,0x4660,0x4660,0x4E60,0x4E80,0x5680,0x5680,0x5E80,0x5E80,0x6680,
0x6680,0x6E80,0x6EA0,0x76A0,0x76A0,0x7EA0,0x7EA0,0x86A0,0x86A0,0x8EA0,
0x8EC0,0x96C0,0x96C0,0x9EC0,0x9EC0,0xA6C0,0xAEC0,0xAEC0,0xB6E0,0xB6E0,
0xBEE0,0xBEE0,0xC6E0,0xC6E0,0xCEE0,0xCEE0,0xD6E0,0xD700,0xDF00,0xDEE0,
0xDEC0,0xDEA0,0xDE80,0xDE80,0xE660,0xE640,0xE620,0xE600,0xE5E0,0xE5C0,
0xE5A0,0xE580,0xE560,0xE540,0xE520,0xE500,0xE4E0,0xE4C0,0xE4A0,0xE480,
0xE460,0xEC40,0xEC20,0xEC00,0xEBE0,0xEBC0,0xEBA0,0xEB80,0xEB60,0xEB40,
0xEB20,0xEB00,0xEAE0,0xEAC0,0xEAA0,0xEA80,0xEA60,0xEA40,0xF220,0xF200,
0xF1E0,0xF1C0,0xF1A0,0xF180,0xF160,0xF140,0xF100,0xF0E0,0xF0C0,0xF0A0,
0xF080,0xF060,0xF040,0xF020,0xF800,};

//plasma
uint16_t plasma[] = {0x0830,0x0830,0x1030,0x1030,0x1030,0x1831,0x1831,0x1831,0x2031,0x2031,0x2031,0x2031,0x2831,0x2832,0x2832,0x2832,0x2832,0x3032,0x3032,0x3032,0x3032,0x3832,0x3812,0x3812,0x3812,0x3813,0x4013,0x4013,0x4013,0x4013,0x4013,0x4813,0x4813,0x4813,0x4813,0x4813,0x5013,0x5013,0x5013,0x5013,0x5014,0x5814,0x5814,0x5814,0x5814,0x5814,0x6014,0x6014,0x6014,0x6014,0x6014,0x6014,0x6814,0x6814,0x6814,0x6814,0x6814,0x7014,0x7014,0x7014,0x7014,0x7014,0x7014,0x7814,0x7814,0x7814,0x7834,0x7834,0x8034,0x8034,0x8034,0x8034,0x8054,0x8054,0x8854,0x8853,0x8873,0x8873,0x8873,0x8893,0x9093,0x9093,0x9093,0x90B3,0x90B3,0x90B3,0x98B3,0x98D3,0x98D2,0x98D2,0x98F2,0x98F2,0xA0F2,0xA0F2,0xA112,0xA112,0xA112,0xA132,0xA131,0xA931,0xA931,0xA951,0xA951,0xA951,0xA951,0xA971,0xB171,0xB170,0xB190,0xB190,0xB190,0xB190,0xB1B0,0xB1B0,0xB9B0,0xB9D0,0xB9CF,0xB9CF,0xB9CF,0xB9EF,0xB9EF,0xB9EF,0xC1EF,0xC20F,0xC20F,0xC20E,0xC22E,0xC22E,0xC22E,0xC22E,0xC24E,0xCA4E,0xCA4E,0xCA6E,0xCA6D,0xCA6D,0xCA6D,0xCA8D,0xCA8D,0xCA8D,0xD2AD,0xD2AD,0xD2AD,0xD2AC,0xD2CC,0xD2CC,0xD2CC,0xD2EC,0xD2EC,0xD2EC,0xDAEC,0xDB0C,0xDB0B,0xDB0B,0xDB2B,0xDB2B,0xDB2B,0xDB2B,0xDB4B,0xDB4B,0xDB4B,0xE36B,0xE36A,0xE36A,0xE36A,0xE38A,0xE38A,0xE38A,0xE3AA,0xE3AA,0xE3AA,0xE3CA,0xE3C9,0xEBC9,0xEBE9,0xEBE9,0xEBE9,0xEBE9,0xEC09,0xEC09,0xEC09,0xEC28,0xEC28,0xEC28,0xEC48,0xEC48,0xEC48,0xEC68,0xEC68,0xF468,0xF488,0xF487,0xF487,0xF4A7,0xF4A7,0xF4A7,0xF4C7,0xF4C7,0xF4C7,0xF4E7,0xF4E6,0xF506,0xF506,0xF506,0xF526,0xF526,0xF526,0xF546,0xF546,0xF546,0xF565,0xF565,0xF585,0xF585,0xF585,0xF5A5,0xF5A5,0xF5A5,0xF5C5,0xF5C5,0xF5E5,0xF5E5,0xF5E4,0xF604,0xF604,0xF624,0xF624,0xF624,0xF644,0xF644,0xF664,0xF664,0xF664,0xF684,0xF684,0xF6A4,0xF6A4,0xF6A4,0xF6C4,0xF6C4,0xF6E4,0xF6E4,0xF6E4,0xF704,0xEF04,0xEF24,0xEF24,0xEF44,0xEF44,0xEF44,0xEF64,0xEF64,0xEF84,0xEF84,0xEFA4,0xEFA4,};

uint16_t *camColors;

Adafruit_AMG88xx amg;

#define AMG_COLS 8
#define AMG_ROWS 8
uint16_t pixels[AMG_COLS * AMG_ROWS];

#define INTERPOLATED_COLS 21
#define INTERPOLATED_ROWS 21
#define TEXT_X            32
#define TEXT_Y            64

#define LIVE_MODE         0
#define SD_MODE           1

uint16_t dest_2d[INTERPOLATED_ROWS * INTERPOLATED_COLS];
uint16_t boxsize;
uint16_t fileNumberWrite = 0;
uint16_t fileNumberRead = 0; 
uint16_t minTemp = 0;
uint16_t maxTemp = 0; 
unsigned long lastWrite = 0;
bool buttonPressed = false;
uint8_t colorMapId = 0;
uint8_t mode = LIVE_MODE;

uint16_t get_point(uint16_t *p, uint8_t rows, uint8_t cols, int8_t x, int8_t y);
void interpolate_image(uint16_t *src, uint8_t src_rows, uint8_t src_cols, 
                       uint16_t *dest, uint8_t dest_rows, uint8_t dest_cols);

void handleButtonPress(void) {
  buttonPressed = true;
}

void setup() {
  //setup tft
  tft.begin();
  //tft.setRotation(3);
  tft.fillScreen(0);
  tft.stroke(255,255,255);
  tft.setTextSize(1);
  
  // setup sd card
  SD.begin(cs_sd);

  EEPROM.get(0,fileNumberWrite);
  EEPROM.get(sizeof(uint16_t),colorMapId);
  fileNumberRead = fileNumberWrite - 1;
  if(colorMapId == 0) {
    camColors = plasma;
    colorMapId = 1;
  }
  else {
    camColors = jet;
    colorMapId = 0;
  }
  EEPROM.put(sizeof(uint16_t),colorMapId);
  drawLegend();
  boxsize = min(tft.width() / INTERPOLATED_COLS, tft.height() / INTERPOLATED_COLS);
  
  // setup temperature sensor
  if(amg.begin()) {
    amg.readPixels(pixels);
  }
  
  pinMode(input,INPUT_PULLUP);
  attachInterrupt(input,handleButtonPress,FALLING);

  // Check the mode (button pressed: read images from sd card)
  if(digitalRead(input) == 0)
    mode = SD_MODE;
}

void loop() {
  //read all the pixels
  //readPixels();
  if (mode == LIVE_MODE) {
    amg.readPixels(pixels);
    updateMinMax();
    interpolate_image(pixels, AMG_ROWS, AMG_COLS, dest_2d, INTERPOLATED_ROWS, INTERPOLATED_COLS);
    drawpixels(dest_2d, INTERPOLATED_ROWS, INTERPOLATED_COLS, boxsize, boxsize);
    if (buttonPressed) {
      saveFile();
      buttonPressed = false;
    }
  } else {
    if (buttonPressed) {
      loadNextFile();
      updateMinMax();
      interpolate_image(pixels, AMG_ROWS, AMG_COLS, dest_2d, INTERPOLATED_ROWS, INTERPOLATED_COLS);
      drawpixels(dest_2d, INTERPOLATED_ROWS, INTERPOLATED_COLS, boxsize, boxsize);
      char filename[10];
      sprintf(filename,"%05d.raw",fileNumberRead + 1);
      tft.text(filename,TEXT_X,TEXT_Y);
      buttonPressed = false;
    }
  }
}

void drawLegend(void)
{
  for (unsigned char y=16;y<tft.height()-16;y++) {
    uint8_t colorIndex = map(y,16,tft.height()-16,0,255);
    tft.drawLine(tft.width()-24,y,tft.width()-8,y,camColors[colorIndex]);
  }
}

void readPixels(void)
{
  for (unsigned int i=0; i< AMG_COLS * AMG_ROWS; i++)
    pixels[i] = (random(MINTEMP, MAXTEMP));
}

void updateMinMax(void) {
  uint16_t newMin = 1000;
  uint16_t newMax = 0;
  for (unsigned int i=0; i< AMG_COLS * AMG_ROWS; i++) {
    newMin = min(newMin,pixels[i]);
    newMax = max(newMax,pixels[i]);
  }
  
  // update legend
  char buffer[6];
  if (newMax/10 != maxTemp/10) {
    maxTemp = newMax;
    tft.fillRect(tft.width()-28, tft.height()-8, 28, 8, 0);
    sprintf(buffer,"%d C",(maxTemp/10));
    tft.text(buffer, tft.width()-28, tft.height()-8);
  }
  if (newMin/10 != minTemp/10) {
    minTemp = newMin;
    tft.fillRect(tft.width()-28, 0, 28, 8, 0);
    sprintf(buffer,"%d C",(minTemp/10));
    tft.text(buffer, tft.width()-28, 0);
  }
}

void saveFile(void) {
  // only allow taking images every two seconds
  if ((millis() - lastWrite) > 2000) {
    lastWrite = millis();
    char filename[10];
    sprintf(filename,"%05d.raw",fileNumberWrite);
    File myFile = SD.open(filename, FILE_WRITE);
    tft.fillRect(TEXT_X,TEXT_Y,54,8,0);
    if(myFile) {
      myFile.write((uint8_t *)pixels,AMG_ROWS*AMG_COLS*sizeof(uint16_t));
      //myFile.print(42);
      myFile.flush();
      myFile.close();
      fileNumberWrite++;
      EEPROM.put(0,fileNumberWrite);
      tft.text(filename,TEXT_X,TEXT_Y);
    } else {
      tft.text("!!Error!!",TEXT_X,TEXT_Y);
    }
    delay(1000);
  } 
}

void loadNextFile(void) {
  // only allow reading images every seconds
  if ((millis() - lastWrite) > 1000) {
    lastWrite = millis();
    char filename[10];
    sprintf(filename,"%05d.raw",fileNumberRead--);
    File myFile = SD.open(filename, FILE_READ);
    if (myFile == 0) { // we have arrived at a file that is not on the card anymore
      fileNumberRead = fileNumberWrite - 1;  // reset filenumber
      sprintf(filename,"%05d.raw",fileNumberRead--);
      myFile = SD.open(filename, FILE_READ);
    }
    myFile.read((uint8_t *)pixels,AMG_ROWS*AMG_COLS*sizeof(uint16_t));
    myFile.close();
  }
}

void drawpixels(uint16_t *p, uint8_t rows, uint8_t cols, uint8_t boxWidth, uint8_t boxHeight) {
  for (int y=0; y<rows; y++) {
    for (int x=0; x<cols; x++) {
      uint16_t val = constrain(get_point(p, rows, cols, x, y),minTemp,maxTemp);
      
      uint8_t colorIndex = map(val, minTemp, maxTemp, 0, 255);
      //draw the pixels!
      tft.fillRect(boxWidth * x, boxHeight * y, boxWidth, boxHeight, camColors[colorIndex]);
    } 
  }
}
